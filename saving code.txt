# Part (a):
def rk4_stepper(h, numsteps, t, y, eq_vector, function_return, k, dummy_y):
    k1 = k[0]
    k2 = k[1]
    k3 = k[2]
    k4 = k[3]
    test_y = []
    test_t = []
    for jk in range(numsteps):
        eq_vector(t, y, function_return)
        k1[0] = h * function_return[0]
        k1[1] = h * function_return[1]
        for i in range(0, 2):
            dummy_y[i] = y[i] + k1[i]/2

        eq_vector(t + h/2, dummy_y, function_return) 
        k2[0] = h * function_return[0]
        k2[1] = h * function_return[1] 
        for i in range(0, 2):  
            dummy_y[i] = y[i] + k2[i]/2

        eq_vector(t + h/2, dummy_y, function_return)
        k3[0] = h * function_return[0]
        k3[1] = h * function_return[1] 
        for i in range(0, 2):
            dummy_y[i] = y[i] + k3[i]

        eq_vector(t + h, dummy_y, function_return) 
        k4[0] = h * function_return[0]
        k4[1] = h * function_return[1]  
        for i in range(0, 2): 
            y[i] = y[i] + (k1[i] + 2*(k2[i] + k3[i]) + k4[i])/6
        
        test_t.append(t)
        test_y.append(y)
        
    k[0] = k1
    k[1] = k2
    k[2] = k3
    k[3] = k4
    
    return test_t, test_y, k


def rk4_vector(start, stop, stepsize, eq_vector, initial_state, precision):
    dummy_y = np.zeros(2)
    y = np.zeros(2)
    y[0] = initial_state[0]
    y[1] = initial_state[1]
    tt = np.array([])
    yy1 = np.array([])
    yy2 = np.array([])
    function_return = np.zeros(2)
    k1 = np.zeros(2)
    k2 = np.zeros(2)
    k3 = np.zeros(2)
    k4 = np.zeros(2)
    k = [k1, k2, k3, k4]
    t = start
    tt = np.append(tt, t)
    yy1 = np.append(yy1, y[0])
    yy2 = np.append(yy2, y[1])
    h = (stop-start)/(1/stepsize)
    h_min = h/64
    error = []
    
    while t < stop:
        if (t+h) > stop:
            h = stop - t
            current_t, current_y, current_k = rk4_stepper(h, 1, t, y, eq_vector, function_return, k, 
                                                         dummy_y)
            
            error.append(np.abs(current_y[-1][1] - test_y[-1][1]))
            y = current_y[-1]
            t = current_t[-1]
            h = previous_h
            yy1 = np.append(yy1, current_y[-1][0])
            yy2 = np.append(yy2, current_y[-1][1])

            tt = np.append(tt, current_t)
            t = current_t[-1]
            break
        
        proposed_factor = 1
        while True:
            proposed_h = h/(2*proposed_factor)
            previous_h = proposed_h * 2
            current_t, current_y, current_k = rk4_stepper(previous_h, 1, t, y, eq_vector, function_return, k, 
                                                         dummy_y)
            test_t, test_y, test_k = rk4_stepper(proposed_h, 2**proposed_factor, t, y, eq_vector, function_return, k, 
                                                dummy_y)
            if np.abs(current_y[-1][1] - test_y[-1][1]) > precision and proposed_h > h_min:
                proposed_factor += 1
                continue
            else:
                error.append(np.abs(current_y[-1][1] - test_y[-1][1]))
                y = current_y[-1]
                t = current_t[-1]
                h = previous_h
                for i in range(len(current_y)):
                    yy1 = np.append(yy1, current_y[i][0])
                    yy2 = np.append(yy2, current_y[i][1])

                tt = np.append(tt, current_t)
                t = current_t[-1]
                break
        
        t+=h
    
    return [tt, yy1, yy2]